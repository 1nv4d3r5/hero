[h1]Forms[/h1]

A critical component of the control panel is *forms*.  Forms are built using an expandable library of fieldtypes (defined as PHP classes at [filename]/app/modules/custom_fields/libraries/fieldtypes/[/filename]).

In the control panel, forms are displayed with the Form_builder library ([filename]/app/modules/custom_fields/libraries/form_builder.php[/filename]).  In the frontend, forms are built by parsing each individual field with the [span_code]{custom_field}[/span_code] template plugin (documented below).

[h2]The Fieldtype Library[/h2]

At the heart of the [APPNAME] form/field architecture is the [span_code]Fieldtype[/span_code] library.  This class is inherited by specific fieldtype definition files (e.g., "text", "select", and "file_upload") and these complete fieldtype objects are manipulated to output proper fields.

This library has a set of "super" methods which load fieldtype definition files, create fieldtype objects from field arrays (retrieved from [span_code]custom_fields_model->get_custom_fields()[/span_code]), and other functions associated with fieldtypes in general.

The library also has methods meant for inheritance by the specific fieldtype objects (e.g., [span_code]$this->name()[/span_code], [span_code]$this->label()[/span_code], [span_code]$this->value()[/span_code]).

If you wanted to use the Fieldtype library to create a Fieldtype object and begin manipulating it, you can do so like so:

[code]
$this->load->library('custom_fields/fieldtype');
$my_text_field = $this->fieldtype->create('text');
$my_text_field->name('fake_field');
$my_text_field->label('Fake Field');
$my_text_field->validators(array('alpha_numeric','trim'));
$my_text_field->required(TRUE);

// retrieve output in the standard admin panel format
$output = $my_text_field->output_admin();
[/code]

In this example, the validators are kind of useless because we aren't running any validation.  But, this code building the field object might be shared amongst a class that both creates the field and validates a post, in which case this makes sense.

It's important to note that the methods like [span_code]name()[/span_code] and [span_code]label()[/span_code] can be chained because they return the field object:

[code]
$my_text_field->name('fake_field')->label('Fake Field')->required(TRUE);
[/code]

Here's a complete list of standard methods available for each fieldtype object:

* [span_code]id(string)[/span_code]
* [span_code]value(string|array)[/span_code]
* [span_code]label(string)[/span_code]
* [span_code]name(string)[/span_code]
* [span_code]help(string)[/span_code]
* [span_code]options(array|serialized_array)[/span_code]
* [span_code]default_value(string|array|serialized_array)[/span_code]
* [span_code]placeholder(string)[/span_code]
* [span_code]required(boolean)[/span_code]
* [span_code]width(string)[/span_code]
* [span_code]validators(array)[/span_code]
* [span_code]li_attribute(name, value)[/span_code]
* [span_code]field_class(string)[/span_code]
* [span_code]data(array)[/span_code]

Fieldtypes can do what they will with the [span_code]data()[/span_code] method and associated property.  For example, the "Content Relationship" fieldtype stores the content_type of it's linked content as [span_code]$this->data['content_type'][/span_code].  For more information on this, you should really just dive into the Fieldtype definition classes.

So, as you can see, you can build and manipulate an isolated Fieldtype object.  However, this is not very practical for a typical application routine.  Most likely, you'll want to build a complete form with the [span_code]Form_builder[/span_code] library described below.

[h2]Using Form_builder (Control Panel Forms)[/h2]

The [span_code]Form_builder[/span_code] library (part of the custom fields module) is a way to combine Field objects into a form.  When the objects are compiled, you can do things like validate the POST submission across all form elements, or retrieve a database-ready array of information based on a POST submission and processed by each Fieldtype object.

[span_code]Form_builder[/span_code] has various methods that are meant specifically to interact with the arrays returned by [span_code]custom_fields_model->get_custom_fields()[/span_code].  For example, to build an entire form from a custom field group:

[code]
$this->load->library('custom_fields/form_builder');
$this->form_builder->build_form_from_group(4); // use custom field group #4

$output = $this->form_builder->output_admin();
$this->form_builder->reset();
[/code]

You could also build a form from a multi-key array of custom fields retrieved from [span_code]custom_fields_model->get_custom_fields()[/span_code] with [span_code]build_form_from_array()[/span_code]:

[code]
$this->load->library('custom_fields/form_builder');
$this->load->model('custom_fields_model');

// get custom fields
$fields = $this->custom_fields_model->get_custom_fields(array('group' => '4'));

$this->form_builder->build_form_from_array($fields);

$output = $this->form_builder->output_admin();
$this->form_builder->reset();
[/code]

[note]The legacy form library, [span_code]Admin_form[/span_code] (in [filename]app/libraries[/filename]), replicates this functionality within its framework:[/note]

[code]
$this->load->library('admin_form');
$this->load->model('custom_fields_model');

// get custom fields
$fields = $this->custom_fields_model->get_custom_fields(array('group' => '4'));

$form = new Admin_form;
$form->custom_fields($fields);

$output = $form->display();
[/code]

Assign from rapidly combining preconfigured custom fields from the database, you can also build forms programatically with [span_code]Form_builder[/span_code] using [span_code]add_field()[/span_code]:

[code]
$this->load->library('custom_fields/form_builder');
$my_text_field = $this->form_builder->add_field('text');
$my_text_field->name('my_text')->label('My Text Field')->default_value('I like this!');

$my_select_field = $this->form_builder->add_field('select');
$my_select_field->name('school')->label('My School')->options(array(
											array('name' => 'MPSS', 'value' => 'MPSS'),
											array('name' => 'CSS', 'value' => 'CSS'),
											array('name' => 'HSS', 'value' => 'HSS')
											))->help('Please select your school.');
											
$output = $this->form_builder->output_admin();
[/code]

[h2]Using {custom_field} (Frontend Forms)[/h2]

Up until now, most of the examples have outputted HTML that is applicable to the control panel.  However, forms also play a major role in the frontend.  Most importantly, you should know how the custom fields you create in the control panel for Member Data &amp; Forms are displayed in the frontend forms.

Each time a custom field is displayed in the frontend, it is passed through the [span_code]{custom_field}[/span_code] template function.  This template function accepts three parameters:

* [span_code]field[/span_code]
* [span_code]value[/span_code]
* [span_code]default[/span_code]

Example calls:

[code]
{custom_field field=$field value=$values[$field.name]}

// will generate HTML based on a $values array (almost always available in registration forms, frontend forms, etc.)
[/code]

[code]
{custom_field field=$field value=$values[$field.name] default=""}

// when we are editing something like a user profile, we don't want to display default data from the fieldtype if there isn't anything in the field.
// otherwise, we'd have some super annoying stuff happening like re-checking checkboxes
[/code]

The [span_code]$field[/span_code] template variable in those examples is generated from [span_code]custom_fields_model->get_custom_fields()[/span_code] like everything else.  It's just an array of field specifications.  It is loaded into the template automatically as part of basic functionality of frontend forms built with [APPNAME], registration forms, profile edits, etc.

[h2]Defining New Fieldtypes[/h2]

Defining a new fieldtype is very easy.  The beauty of this system is that you can just drop in a single file to [filename]app/modules/custom_fields/libraries/fieldtypes/[/span_code] and have a new fieldtype available across the entire system.  The default Fieldtypes are highly documented and very simple to modify, so it's best to take an existing fieldtype and adopt it to your needs.

Each fieldtype has the following methods:

* [span_code]construct()[/span_code]
* [span_code]output_admin()[/span_code]
* [span_code]output_frontend()[/span_code]
* [span_code]field_form()[/span_code] - Build the form to add/edit fields of this type in the control panel
* [span_code]field_form_process()[/span_code] - Process the submission of the above form (returns an array)
* [span_code]post_to_value()[/span_code] - Convert a POST submission into a database-ready value for this field
* [span_code]validate_post()[/span_code] - Return [span_code]form_validation[/span_code] library rules for this field, based on its current settings
* [span_code]additional_validation()[/span_code] - Perform any additional, atypical validation routines (e.g, validate file upload extensions)

[h2]Legacy Forms: Admin_form[/h2]

If you don't need the object-oriented nature of the Fieldtype library, and just want to quickly build a form that is formatted for the control panel, you can use the [span_code]Admin_form[/span_code] library.

This library has various methods (fully documented in the library file) like [span_code]text()[/span_code], [span_code]textarea()[/span_code], [span_code]dropdown()[/span_code], etc.  All of the basic HTML fieldtypes are there.  However, you lose the expandibility of [span_code]fieldtype[/span_code] + [span_code]form_builder[/span_code].