[h1]Module Development[/h1]

A *module* is a collection of files that add new functionality to the platform.  These files can function entirely in the background (e.g., small integration plugins) or include control panel interfaces and frontend modules.  They can also include database tables, session access, etc.

Third-party modules created by developers and standard modules included in the application share identical rights within the application.

Creating a module is simple and *requires* the following:

* A folder: [filename]app/modules/modulename/[/filename]
* A module definition and installation file: [filename]app/modules/modulename/modulename.php[/filename]

Optionally, you can add the following:

* One or more model definition files at: [filename]app/modules/modulename/models/[modelname]_model.php[/filename]
* A control panel controller file at: [filename]app/modules/modulename/controllers/admincp.php[/filename]
* Other controller files at: [filename]app/modules/modulename/controllers/[/filename]
* A views folder for control panel interface screens: [filename]app/modules/modulename/views/[/filename]
* Helper files in: [filename]app/modules/modulename/helpers/[/filename]
* Library files in: [filename]app/modules/modulename/libraries/[/filename]

Developers have access to all standard [http://www.codeigniter.com/user_guide](CodeIgniter) libraries/helpers, as well as a number of additional libraries and helpers specific to this application.  So, it's highly encouraged to use the [http://www.codeigniter.com/user_guide](CodeIgniter documentation) as much as possible.

For more information on these, check out the following documentation for commonly-used classes:

* [developers/classes/admin_form](Administration Form Library) (Admin_form)
* [developers/classes/dataset](Dataset Listing Library) (Dataset)
* [developers/classes/notifications](Notification Library) (Notifications)
* [developers/classes/navigation](Navigation Library) (Navigation)
* [developers/classes/links](Universal Links Model) (Link_model)
* [developers/classes/settings](Settings Model) (Settings_model)

Furthermore, in the frontend, developers have access to the Smarty API and are highly encouraged to use the included [http://www.smarty.net](Smarty templating engine) for displaying their web pages.

This documentation will cover each potential component of a module.

[h2]Module Definition & Installation File ([filename]app/modules/modulename/modulename.php[/filename])[/h2]

This file has 3 main responsibilities:

1) Perform any installation or upgrade tasks, such as database table creation/modification, settings creation, and writeable folder creation.
2) Universal control preload operations such as displaying navigation items.  These occur upon each page load of the control panel.
3) Universal frontend preload operations such as adding Smarty template plugin folders.

First, we must define the class, mandatory variables, and class constructor (required by all modules):

[code]
class Modulename extends Module {
	var $version = '1.0';
	var $name = 'Module Name';
	
	function __construct {
		$this->active_module = $this->name;
		
		parent::__construct();
	}
}
[/code]

Here, we've specified the current module name as well as version.  We've also extended the Module class which handles much of the shared logic for modules.

[note]If there is a class conflict (e.g., your frontend controller class is [span_code]Modulename[/span_code] and you can't use [span_code]Modulename[/span_code] for the module definition class), you can use [span_code]Modulename_module[/span_code] (e.g., "[span_code]Search_module[/span_code]") as the class name for the module definition file.[/note]

The CodeIgniter superobject is now accessible within our module definition class at $this->CI.

*No other code is required* in the module definition, but few modules will be that simple.

For example, we may want to include some installation/upgrade logic with a method like so:

[code]
class Modulename extends Module {
	// ... variables and __construct() method ...
	
	/**
	* Update
	*
	* @param int $db_version The current version of the installed module and its database, if applicable
	*
	* @return int $version The updated version (i.e., the version of this module file)
	*/
	function update ($db_version) {
		if ($db_version < 1.0) {
			// this would be a fresh install, as it's less than 1.0
		}
		
		if ($db_version < 1.02) {
			// this second command is an upgrade, something to run only if they don't
			// already have version 1.02 installed
		}
		
		return $this->version;
	}
}
[/code]

Keep in mind that, if your module is in version 1.05 (for example), and you have 5 [span_code]if[/span_code] statements performing separate operations, all 5 of these statements will be executed upon a fresh install.  You don't need to modify each one repeatedly adding the new logic.

Right now, our module defines itself and performs some installation/update logic.

We will now add a new item to the control panel navigation via a new method, [span_code]admin_preload()[/span_code].  This method, if it exists, is run prior to any control panel screen running.

[code]
class Modulename extends Module {
	// ... variables, constructor, updator logic, etc...
	
	function admin_preload () {
		$this->CI->navigation->child_link('configuration',60,$this->name . ' Configuration',site_url('admincp/modulename/configuration'));
	}
}
[/code]

The single line in the admin_preload method above adds a new navigation link to the control panel as a sub-link of the "configuration" tab.  It's weight is "60" (i.e., it appears after something weighted 59 but before links weighted 61), has "Module Name Configuration" as its text, and links to [url]/admincp/modulename/configuration[/url].  Your module's control panel controller is always accessible at [url]/admincp/modulename[/url], and here we are specifying the configuration method within that controller.

Similarly to [span_code]admin_preload()[/span_code], [span_code]front_preload()[/span_code] is executed prior to every page load in the frontend.  It is less commonly used than [span_code]admin_preload()[/span_code], but can be useful when your module adds new Smarty template plugins or needs to attach a function to an application hook.

Here, we will say that we are adding a new folder filled with Smarty plugins in our module:

[code]
class Modulename extends Module {
	// ... all other module code ...
	
	function front_preload () {
		$this->CI->smarty->addPluginsDir(APPPATH . 'modules/modulename/template_plugins/');
	}
}
[/code]

Now, Smarty will look in this directory for function/block plugin files like [filename]function.your_plugin.php[/filename].  For more information on creating template plugins, via our [developers/template_plugins](documentation on creating a template plugin).

[h2]Model File(s) ([filename]app/modules/modulename/models/your_model.php[/filename])[/h2]

These model definition files are standard CodeIgniter model files.  They usually contain a series of methods used for creating, updating, and deleting database records related to your module. For more information on models, look at [http://www.codeigniter.com/user_guide](CodeIgniter's documentation).

[h2]Control Panel File ([filename]app/modules/modulename/controllers/admincp.php[/filename])[/h2]

If your module has at least one control panel screen, you must create this control panel controller file.  This controllers allows for control panel pages to be viewable at [url]/admincp/modulename[/url].  This main URL will automatically load the [span_code]index()[/span_code] method in your controller (e.g., your module's control panel home page).  A 3rd URI segment (e.g., [url]/admincp/modulename/another_method[/url]) will prompt that method to be loaded in your control panel controller.  All URL segments after this 3rd segment are passed as the first, second, third, (etc.) arguments to the specified method.

Examples:

* [url]admincp/builder[/url] loads the [span_code]index()[/span_code] method of the Admincp controller at [filename]app/modules/builder/controllers/admincp.php[/filename]
* [url]admincp/builder/post[/url] loads the [span_code]post()[/span_code] method of the Admincp controller
* [url]admincp/builder/post/editing[/url] loads the [span_code]post($form)[/span_code] method of the Admincp controller with [span_code]$form == 'editing'[/span_code]

As a start, your control panel controller will include the following code:

[code]
class Admincp extends Admincp_Controller {
	function __construct()
	{
		parent::__construct();
				
		// sets the active navigation tab to "publish"
		// 	other options: storefront, members, reports, design, configuration
		// you can re-specify or change this within any method, as well
		$this->navigation->parent_active('publish');
	}
}
[/code]

You should also have an [span_code]index()[/span_code] method to be displayed at [url]/admincp/modulename[/url].  If not, and the user accesses this page, they will get a 404 error.

As for other methods, you can add as many as you would like.  These are standard CodeIgniter controllers so all [http://www.codeigniter.com/user_guide](CodeIgniter documentation) applies.

You can also look to existing modules as well as well as other developer documentation for building these methods, whether you want to to build [developers/forms](forms) in the control panel or use the powerful records-listing [developers/dataset](dataset library).

[h2]Frontend Controller Files ([filename]app/modules/modulename/controllers/[/filename])[/h2]

Frontend controller files give your module a presence in the frontend.  For example, the Publish module has a frontend controller called "content" which displays a piece of content retrieved via the content model.

Frontend controllers automatically map to URL's.  For example, if a controller called "test.php" existed at [filename]app/modules/test/test.php[/filename], it would be accessible at [url]/modulename/test[/url], and any methods inside of it are accessible at [url]/modulename/test/method_name[/url].

Besides these automatically-mapping URL's, you can map your controllers to arbitrary URL's by tapping into the [developers/links](universal links model) (class name, [span_code]link_model)[/span_code]).  By registering a link with this model, you can map any URL path (such as [url]/my/fake/url/path[/url]) to the module > controller > method of your choice.  The URL path will be passed to your method as its first argument.  For example, in the Publish module, URL's like [url]/my_article[/url] are mapped to publish (module) > content (controller) > view (method).  The [span_code]content->view()[/span_code] method takes one argument, [span_code]$url_path[/span_code], and looks up the content in the database using this [span_code]$url_path[/span_code].

As a start, your frontend controller must extend the [span_code]Front_Controller[/span_code] class and call its parent's constructor:

[code]
class Any_controller_name extends Front_Controller {
	function __construct() {
		parent::__construct();
	}
}
[/code]

If a URL maps to your controller but the method is non-existent, a 404 error will be returned.  Also, within any of your methods, you can programatically return a 404 error to the user like so:

[code]
class Any_controller_name extends Front_Controller {
	function __construct() {
		parent::__construct();
	}
	
	function view ($url_path) {
		$this->load->model('modulename/module_model.php');
		$item = $this->module_model->get_item($url_path);
		
		if (empty($item)) {
			// no such item exists with that URL
			return show_404($url_path);
		}
		
		// else show the item nicely with a page...
	}
}
[/code]

Frontend controllers will almost always assign variables and display templates with the Smarty template engine and API.  [http://www.smarty.net](Click here for more information on Smarty).

[h2]Views, Helpers, and Libraries[/h2]

These are all optional components of your module and also standard parts of the CodeIgniter framework.  They exist at the following folders but are not required for any module:

* [filename]app/modules/modulename/views/[/filename]
* [filename]app/modules/modulename/helpers/[/filename]
* [filename]app/modules/modulename/libraries/[/filename]

Views are most commonly used for control panel screens (frontend pages use the [http://www.smarty.net](Smarty template engine)).

Helpers are one-off function definitions that provide additional functionality.

Libraries are simple class files and are not required to extend any base classes.

All 3 can be loaded via the load method on the CodeIgniter superobject (e.g., [span_code]$this->CI->load()[/span_code] in module definition files, [span_code]$this->load()[/span_code] in models/controllers).  More information is available in [http://www.codeigniter.com/user_guide](CodeIgniter documentation).